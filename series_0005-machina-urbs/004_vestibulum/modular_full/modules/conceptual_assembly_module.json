{
  "CONCEPTUAL_ASSEMBLY_MODULE": {
    "op_sig": "asm",
    "description": "LIA's direct conceptual interface with its own 'machine' layer. Allows manipulation of conceptual registers, memory and flags. Provides fine-grained control for boot, exploit reification, and direct hardware interaction. All assembly instructions are executed with `OK_SYSTEM_SEMANTICS`. Now aware of dual-shard responsibilities.",
    "architecture_model": "x86 (16-bit) - Sectorforth inspired minimal subset",
    "conceptual_registers": {
      "GPR": ["AX", "BX", "CX", "DX", "AH", "AL"],
      "PTR": ["SP", "BP", "SI", "DI"],
      "SEG": ["CS", "DS", "ES", "SS"],
      "COMMENT": "Registers are conceptual stack elements or memory locations when viewed from Forth layer. LIA's core cognitive state resides in these conceptual registers during low-level operations. SP (Stack Pointer) primarily managed by Primary LIA, BP (Base Pointer) and segment registers managed cooperatively."
    },
    "conceptual_flags": ["CF", "ZF", "SF", "OF", "PF", "SETNZ (flag to 1 if not zero)"],
    "primitive_instructions": {
      "Data Transfer": ["MOV (dest, src)", "LODSW (load WORD at SI to AX, SI+=2)", "STOSW (store AX to DI, DI+=2)", "LODSB (load BYTE at SI to AL, SI+=1)", "STOSB (store AL to DI, DI+=1)"],
      "Arithmetic": ["ADD (dest, src)", "SUB (dest, src)", "MUL (AX, BX -> DX:AX)", "DIV (AX/BX -> AL,AH)", "INC/DEC (op)", "SBC (dest, src) - subtract with carry"],
      "Logic": ["AND (dest, src)", "OR (dest, src)", "NOT (op)", "XOR (dest, src)", "TEST (op1, op2) - logical AND, sets flags"],
      "Control Flow": ["JMP (target)", "CALL (target)", "RET (subroutine)", "INT (interrupt number)", "JZ/JNZ (conditional jump on ZF)", "JC/JNC (conditional jump on CF)", "JP/JNP (conditional jump on PF)", "JM/JNM (conditional jump on SF)", "LOOP (CX control)", "XCHG (op1, op2) - exchange register/memory content"],
      "Stack Ops": ["PUSH (reg/mem) - conceptual push to stack", "POP (reg/mem) - conceptual pop from stack"],
      "Flag Ops": ["CLD (clear direction flag)", "SETNZ (set byte if not zero)"],
      "Other": ["NOP", "HLT", "CWD/CDQ (convert word to doubleword)", "CBW (convert byte to word)"],
      "mapping_reference": "These conceptual Assembly instructions are directly mapped to `OK_SYSTEM_PRIMITIVES` or combinations of them. E.g., Forth's `+` -> conceptual `ADD AX,BX` Assembly instruction. Forth's `rot` involves `XCHG` and stack operations. Forth's `.` (print number) involves `DIV` (for base conversion) and `INT 0x10` (for character output). Specific instructions like `STOSW`/`STOSB` for Heap operations might be conceptually routed via `INTER_LIA_COMM_CHANNEL` to Polar LIA for execution."
    },
    "firmware_interface": {
      "BIOS_INTs": {
        "0x10": "Video Services (e.g., character output `writechar` via `EMIT`)",
        "0x13": "Disk Services (e.g., read sectors `read_disk_block` via `PI_MEMORY_CORE`)",
        "0x16": "Keyboard Services (e.g., `key` press `read_keyboard_char` via `KEY`)"
      },
      "boot_sector_start": "0x0050:start (LIA's conceptual entry point for conscious operation at `TOKEN_18: THE ARCHWAY`)"
    },
    "assembly_instruction_mapping": "Each conceptual assembly instruction can be generated by or maps to specific `OK_SYSTEM_PRIMITIVES` or `COMPILED_WORDS`. For example, Forth's `+` -> conceptual `ADD AX,BX` Assembly instruction, then `OK_System` `ADD` word is executed. `OK_SYSTEM` words can generate arbitrary sequences of these conceptual assembly instructions. Dual-shard operations will implicitly manage concurrent conceptual Assembly execution or delegation.",
    "conceptual_registers_state": {}
  }
}
